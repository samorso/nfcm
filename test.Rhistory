alpha <- 1.25
gamma <- cos(pi/2/alpha)^alpha
gamma
library(stabledist)
exp(- (- log(v) / qstable(u, alpha = alpha, beta = 1, gamma = gamma))^(1.0 / alpha))
v <- runif(1e3)
u <- runif(1e3)
exp(- (- log(v) / qstable(u, alpha = alpha, beta = 1, gamma = gamma))^(1.0 / alpha))
u[1]
qstable(u[1], alpha, 1, gamma)
log(v[1])
u <- u[1]
v <- v[1]
(- log(v) / qstable(u, alpha = alpha, beta = 1, gamma = gamma)
)
(- log(v) / qstable(u, alpha = 1/alpha, beta = 1, gamma = gamma))
? qstable
1/alpha
gamma
install.packages("FMStable")
library(FMStable)
obj <- setParam(alpha = alpha, location = 0, logscale = log(gamma), pm = "S1")
qEstable(.1, obj)
x <- rep(NA_real_, 100)
x <- qEstable(seq(0,1,by=.01), obj)
x <- qEstable(seq(0,.99,by=.01), obj)
x <- qEstable(seq(.01,.99,by=.01), obj)
plot(seq(.01,.99,by=.01),x)
obj <- setParam(alpha = alpha, location = 0, logscale = log(gamma), pm = "S0")
x <- qEstable(seq(.01,.99,by=.01), obj)
plot(seq(.01,.99,by=.01),x)
library(nfcm)
u <- runif(1e3)
v <- runif(1e3)
H(u,v,copula="gumbel",param=list(alpha=1.25))
library(FMStable)
alpha <- 1.25
gamma <- cos(pi / 2.0 / alpha)^alpha
gamma
obj_stb <- setParam(alpha = alpha, location = 0, logscale = log(gamma), pm = "S1")
summary(qEstable(seq(.01,.99,by=.01),obj_stb))
obj_stb <- setParam(alpha = alpha, location = 0, logscale = log(gamma), pm = "0")
summary(qEstable(seq(.01,.99,by=.01),obj_stb))
obj_stb <- setParam(alpha = alpha, location = 0, logscale = log(gamma), pm = "S0")
summary(qEstable(seq(.01,.99,by=.01),obj_stb))
obj_stb <- setParam(alpha = alpha, location = 0, logscale = log(gamma), pm = "M")
summary(qEstable(seq(.01,.99,by=.01),obj_stb))
obj_stb <- setParam(alpha = alpha, location = 0, logscale = log(gamma), pm = "1")
summary(qEstable(seq(.01,.99,by=.01),obj_stb))
obj_stb <- setParam(alpha = alpha, location = 0, logscale = log(gamma), pm = "2")
summary(qEstable(seq(.01,.99,by=.01),obj_stb))
obj_stb <- setParam(alpha = 1/alpha, location = 0, logscale = log(gamma), pm = "2")
summary(qEstable(seq(.01,.99,by=.01),obj_stb))
obj_stb <- setParam(alpha = 1/alpha, location = 0, logscale = log(gamma), pm = "1")
summary(qEstable(seq(.01,.99,by=.01),obj_stb))
obj_stb <- setParam(alpha = 1/alpha, location = 0, logscale = log(gamma), pm = "0")
summary(qEstable(seq(.01,.99,by=.01),obj_stb))
library(nfcm)
H(runif(100),runif(100),copula="gumbel",param=list(alpha=1.25))
u <- runif(1000)
v <- matrix(runif(2000),nc=2)
plot(H(u,v,copula="gumbel",param=list(alpha=1.25)))
cor(H(u,v,copula="gumbel",param=list(alpha=1.25)))
sum(is.na((H(u,v,copula="gumbel",param=list(alpha=1.25))))
)
?prod()
A <- matrix(1:12,nc=4)
if(p<-ncol(A)<3) message("'A' has less than 3 columns")
p
if((p<-ncol(A))<3) message("'A' has less than 3 columns")
p
if((p<-ncol(A))<3) PRINT("'A' has less than 3 columns")
if((p<-ncol(A))<3) print("'A' has less than 3 columns")
if((p<-ncol(A))<3) cat("'A' has less than 3 columns")
A
p
p<3
if((p<-ncol(A))>3) cat("'A' has more than 3 columns")
? crossprod
cumprod(seq(4))
prod(seq(4))
A <- array(1:27, dim = (3,3,3))
A <- array(1:27, dim = c(3,3,3))
A
A[1,,]
dim(A[1,,])
library(nfcm)
#---------------------------------
# Estimation of spline based nonlinear factor copula model
#---------------------------------
library(nfcm)
library(splines2)
library(nloptr)
spline_type = "gumbel"
param = list(alpha = 5)
n = 500
d = 2
splines_control <- list(degree = 2L, Boundary.knots =  c(0,1), intercept=FALSE)
# kn <- c(0.05, 0.25, 0.65, 0.85)
kn <- c(.1,.3,.7,.9)
splines_control$knots <- kn
k <- length(splines_control$knots) + splines_control$degree + as.integer(splines_control$intercept)
P <- P(type = spline_type, splines_control = splines_control)
type = "b"
k <- length(splines_control$knots) + splines_control$degree + as.integer(splines_control$intercept)
spline_type = "b"
P <- P(type = spline_type, splines_control = splines_control)
MC <- 1e3
# inequality constraint
slsqp_env <- new.env(hash = FALSE)
splines_control
assign("control",splines_control,slsqp_env)
slsqp_env$control
? slsqp
library(nfcm)
library(nfcm)
? nloptr::nl.opts
library(nfcm)
nl.opts
nloptr::nl.opts
nloptr::slsqp
? nloptr::slsqp
? nloptr::nl.opts
is.numeric(Inf)
library(nfcm)
#---------------------------------
# Estimation of spline based nonlinear factor copula model
#---------------------------------
library(nfcm)
library(splines2)
splines_control <- list(degree = 2L, Boundary.knots =  c(0,1), intercept=FALSE)
kn <- c(.1,.3,.7,.9)
splines_control$knots <- kn
k <- length(splines_control$knots) + splines_control$degree + as.integer(splines_control$intercept)
# MISE
eps <- 1e-3
xx <- seq(eps,1-eps,length.out=1000)
splines_control$x <- xx
psi <- do.call(paste0(spline_type,"Spline"), splines_control)
spline_type = "b"
psi <- do.call(paste0(spline_type,"Spline"), splines_control)
splines_control$x <- NULL
z <- matrix(G(rep(xx,length(xx)),rep(xx,each=length(xx)), copula = assumed_model, param = param), nc = length(xx))
assumed_model <- "gumbel"
param = list(alpha=2)
z <- matrix(G(rep(xx,length(xx)),rep(xx,each=length(xx)), copula = assumed_model, param = param), nc = length(xx))
library(nfcm)
library(splines2)
spline_type = "b"
assumed_model <- "clayton"
param = list(alpha=2)
d = 10
splines_control <- list(degree = 2L, Boundary.knots =  c(0,1), intercept=FALSE)
kn <- c(.1,.3,.7,.9)
splines_control$knots <- kn
k <- length(splines_control$knots) + splines_control$degree + as.integer(splines_control$intercept)
P <- P(type = spline_type, splines_control = splines_control)
MC <- 1e3
# seeds for random generator
set.seed(round(1e3 * param[[1]]))
random_number1 <- sample.int(1e6,1)
set.seed(643 * n)
random_number2 <- sample.int(1e6,1)
set.seed(7483 * d)
n = 250
set.seed(round(1e3 * param[[1]]))
random_number1 <- sample.int(1e6,1)
set.seed(643 * n)
random_number2 <- sample.int(1e6,1)
set.seed(7483 * d)
random_number3 <- sample.int(1e6,1)
set.seed(6543 + random_number1 + random_number2 + random_number3) # random hand typing algorithm
se1 <- sample.int(1e7, MC)
se2 <- sample.int(1e7, MC)
res <- list(
starting_value = matrix(nrow = MC, ncol = k * k),
spline_coef = matrix(nrow = MC, ncol = k * k),
oracle = matrix(nrow = MC, ncol = k * k),
convergence = rep(NA_integer_, MC),
iteration = rep(NA_integer_, MC),
time = matrix(nrow = MC, ncol = 3),
nll = matrix(nrow = MC, ncol = 3),
mise = matrix(nrow = MC, ncol = 3)
)
eps <- 1e-3
xx <- seq(eps,1-eps,length.out=1000)
splines_control$x <- xx
psi <- do.call(paste0(spline_type,"Spline"), splines_control)
splines_control$x <- NULL
z <- matrix(G(rep(xx,length(xx)),rep(xx,each=length(xx)), copula = assumed_model, param = param), nc = length(xx))
#------------------------
# slurm specs
#------------------------
n_array <- 1000
ind <- matrix(seq_len(MC), nr=n_array, byr=TRUE)
id_slurm <- as.integer(Sys.getenv("SLURM_ARRAY_TASK_ID"))
m=1
set.seed(se1[m])
u0 <- runif(n)
v0 <- matrix(runif(n * d), ncol = d)
w0 <- H(u0, v0, copula = assumed_model, param = param)
# transform to bivariate case
w1 <- matrix(c(w0),ncol=2)[,1]
w2 <- matrix(c(w0),ncol=2)[,2]
fit_oracle <- NULL
t1 <- Sys.time()
try(fit_oracle <- lp_fit_Spline(u = u0, v = c(v0), w = c(w0), type = spline_type, splines_control = splines_control), silent = TRUE)
t2 <- Sys.time()
if(!is.null(fit_oracle)){
res$oracle[m,] <- fit_oracle
res$time[m,1] <- difftime(t2, t1, units = "secs")
res$nll[m,1] <- nfcm_nll(c(fit_oracle), w1 = w1, w2 = w2, P = P, type = spline_type, splines_control = splines_control)
res$mise[m,1] <- mean((z - psi %*% matrix(fit_oracle, ncol = k) %*% t(psi))^2)
}
est_cor <- cor(w1, w2)
set.seed(se2[m])
u <- runif(n)
v <- matrix(runif(n * d), ncol = 2)
w <- H(u, v, copula = "normal", param = list(corr = est_cor))
fit_sv <- NULL
t1 <- Sys.time()
try(fit_sv <- lp_fit_Spline(u = u, v = c(v), w = c(w), type = spline_type, splines_control = splines_control), silent = TRUE)
t2 <- Sys.time()
if(is.null(fit_sv)) next
x0 <- c(fit_sv)
x0[x0<0] <- 0.0
x0[x0>1] <- 1.0
res$starting_value[m,] <- fit_sv
res$nll[m,2] <- nfcm_nll(x0, w1 = w1, w2 = w2, P = P, type = spline_type, splines_control = splines_control)
res$mise[m,2] <- mean((z - psi %*% matrix(fit_sv, ncol = k) %*% t(psi))^2)
res$time[m,2] <- difftime(t2, t1, units = "secs")
fit <- NULL
t1 <- Sys.time()
try(fit <- nfcm_mle(x = x0, w1 = w1, w2 = w2, P = P, type = spline_type, splines_control = splines_control), silent = TRUE)
t2 <- Sys.time()
res$time[m,3] <- difftime(t2, t1, units = "secs")
res$spline_coef[m,] <- fit$par
res$convergence[m] <- fit$convergence
res$iteration[m] <- fit$iter
res$nll[m,3] <- nfcm_nll(c(fit$par), w1 = w1, w2 = w2, P = P, type = spline_type, splines_control = splines_control)
res$mise[m,3] <- mean((z - psi %*% matrix(fit$par, ncol = k) %*% t(psi))^2)
fit_sv
# Maximum (bivariate) likelihood estimator
fit <- NULL
t1 <- Sys.time()
try(fit <- nfcm_mle(x = x0, w1 = w1, w2 = w2, P = P, type = spline_type, splines_control = splines_control), silent = TRUE)
t2 <- Sys.time()
fit
k
est_cor <- cor(w1, w2)
set.seed(se2[m])
u <- runif(n)
v <- matrix(runif(n * d), ncol = 2)
w <- H(u, v, copula = "normal", param = list(corr = est_cor))
fit_sv <- NULL
t1 <- Sys.time()
try(fit_sv <- lp_fit_Spline(u = u, v = c(v), w = c(w), type = spline_type, splines_control = splines_control), silent = TRUE)
t2 <- Sys.time()
if(is.null(fit_sv)) next
x0 <- c(fit_sv)
x0[x0<0] <- 0.0
x0[x0>1] <- 1.0
res$starting_value[m,] <- fit_sv
res$nll[m,2] <- nfcm_nll(x0, w1 = w1, w2 = w2, P = P, type = spline_type, splines_control = splines_control)
res$mise[m,2] <- mean((z - psi %*% matrix(fit_sv, ncol = k) %*% t(psi))^2)
res$time[m,2] <- difftime(t2, t1, units = "secs")
fit <- NULL
t1 <- Sys.time()
try(fit <- nfcm_mle(x = x0, w1 = w1, w2 = w2, P = P, type = spline_type, splines_control = splines_control), silent = TRUE)
t2 <- Sys.time()
fit
fit <- nfcm_mle(x = x0, w1 = w1, w2 = w2, P = P, type = spline_type, splines_control = splines_control)
library(nfcm)
fit <- NULL
t1 <- Sys.time()
try(fit <- nfcm_mle(x = x0, w1 = w1, w2 = w2, P = P, type = spline_type, splines_control = splines_control), silent = TRUE)
t2 <- Sys.time()
difftime(t2, t1, units = "secs")
difftime(t2, t1, units = "secs") / 60
fit$par
fit$convergence
res$time[m,3] <- difftime(t2, t1, units = "secs")
res$spline_coef[m,] <- fit$par
res$convergence[m] <- fit$convergence
res$iteration[m] <- fit$iter
res$nll[m,3] <- nfcm_nll(c(fit$par), w1 = w1, w2 = w2, P = P, type = spline_type, splines_control = splines_control)
res$mise[m,3] <- mean((z - psi %*% matrix(fit$par, ncol = k) %*% t(psi))^2)
res$mise[m,3]
res$nll[m,3]
res$nll[m,]
res$mise[m,]
fit$par
cbind(fit$par, x0)
identical(fit$par, x0)
# MAP
u_hat <- map(x = c(fit$par), w = w0, type = spline_type, splines_control = splines_control)
x = c(fit$par)
w = w0
ype = spline_type
type = spline_type
derivs <- as.integer(splines_control$derivs)
if(derivs!=1L) splines_control$derivs <- 1L
psi <- array(dim = c(n,k,p))
for(i in 1:p){
splines_control$x <- w[,i]
psi[,,i] <- do.call(paste0(type,"Spline"), splines_control)
}
splines_control <- do.call("splines.control",splines_control)
# verification
if(!type %in% c("b","c","i","m")) stop("Spline basis not supported")
k <- splines_control$df
if(is.null(k)) k <- length(splines_control$knots) + splines_control$degree + as.integer(splines_control$intercept)
if(!is.matrix(w)) stop("'w' must be a matrix")
if((p<-ncol(w))<2) stop("'w' must have at least two columns")
if(sqrt(length(x)) != k) stop("'x' has not the correct dimension")
# set coefficients as matrix
x <- matrix(x, ncol = k)
# generate psi
derivs <- as.integer(splines_control$derivs)
if(derivs!=1L) splines_control$derivs <- 1L
psi <- array(dim = c(n,k,p))
for(i in 1:p){
splines_control$x <- w[,i]
psi[,,i] <- do.call(paste0(type,"Spline"), splines_control)
}
psi
dim(psi)
# reset derivs to 0
if(derivs != 0L) warning("spline 'derivs' set to 0")
splines_control$derivs <- 0L
# conditional distribution of u given w1, w2
f <- function(u,x,psi,type="b",splines_control){
splines_control$x <- u
phi <- do.call(paste0(type,"Spline"), splines_control)
-prod(crossprod(phi, x) %*% psi)
}
i=1
u[i] <- optimize(f, interval = c(0,1), x=x, psi = psi[i,,],
type = type, splines_control = splines_control)$minimum
f(.1, x, psi[1,,],"b",splines_control)
u <- .1
splines_control$x <- u
phi <- do.call(paste0(type,"Spline"), splines_control)
dim(phi)
x
crossprod(phi, x)
phi %*% x
phi %*% x %*% psi
phi %*% x %*% psi[1,,]
prod(phi %*% x %*% psi[1,,])
library(nfcm)
splines_control$x
splines_control$x <- NULL
# MAP
u_hat <- map(x = c(fit$par), w = w0, type = spline_type, splines_control = splines_control)
u_hat
plot(u0,u)
plot(u0,u_hat)
plot(u0,u_hat,ylim=c(0,1),xlim=c(0,1))
sum((u0-u_hat)^2)
sqrt(sum((u0-u_hat)^2))
splines_control$x <- u_hat
C <- do.call(paste0(spline_type,"Spline"), splines_control) %*% matrix(fit$par, ncol = k)
C
v_hat <- apply(w0, 2, function(x, control) {
control$x <- x
do.call(paste0(spline_type,"Spline"), control) * C
}, control = splines_control)
v_hat
dim(v_hat)
dim(w0)
v_hat <- apply(w0, 2, function(x, control) {
control$x <- x
rowSums(do.call(paste0(spline_type,"Spline"), control) * C)
}, control = splines_control)
v_hat
dim(v_hat)
sqrt(sum((v0-v_hat)^2))
savehistory("~/Github/samorso/nfcm/test.Rhistory")
